<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>WebGL2 depth readPixels probe</title>
    <style>
      body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; margin: 16px; background: #0b0f16; color: #e8eefc; }
      .row { display: flex; gap: 16px; flex-wrap: wrap; }
      canvas { border: 1px solid #263248; background: #0b0f16; image-rendering: pixelated; }
      pre { background: #0f1726; border: 1px solid #263248; border-radius: 8px; padding: 12px; overflow: auto; max-height: 70vh; min-width: min(900px, 95vw); }
      button { background: #1b2a44; color: #e8eefc; border: 1px solid #2b3a55; border-radius: 8px; padding: 8px 10px; cursor: pointer; }
      button:hover { background: #223457; }
      .hint { color: #b8c7ea; line-height: 1.4; max-width: 980px; }
      a { color: #9cc2ff; }
      code { color: #cfe2ff; }
    </style>
  </head>
  <body>
    <h2>WebGL2 depth readPixels probe</h2>
    <div class="hint">
      This page tests depth readback support on your browser/GPU:
      <ul>
        <li><b>Depth readPixels</b>: <code>readPixels(DEPTH_COMPONENT, UNSIGNED_SHORT)</code> from a <code>DEPTH_COMPONENT16</code> attachment.</li>
        <li><b>RGBA fallback</b>: render depth texture into an <code>RGBA8</code> texture via shader and <code>readPixels(RGBA)</code>.</li>
      </ul>
      If you see <code>INVALID_ENUM</code> for depth readPixels but RGBA fallback succeeds, that's exactly what the viewer now uses.
    </div>

    <p>
      <button id="run">Run probe</button>
      <button id="clear">Clear log</button>
    </p>

    <div class="row">
      <canvas id="c" width="256" height="256"></canvas>
      <pre id="log"></pre>
    </div>

    <script>
      const $log = document.getElementById('log');
      const log = (...args) => { $log.textContent += args.map(String).join(' ') + '\n'; };
      const clearLog = () => { $log.textContent = ''; };

      function glErrName(gl, e) {
        const m = new Map([
          [gl.NO_ERROR, 'NO_ERROR'],
          [gl.INVALID_ENUM, 'INVALID_ENUM'],
          [gl.INVALID_VALUE, 'INVALID_VALUE'],
          [gl.INVALID_OPERATION, 'INVALID_OPERATION'],
          [gl.OUT_OF_MEMORY, 'OUT_OF_MEMORY'],
          [gl.INVALID_FRAMEBUFFER_OPERATION, 'INVALID_FRAMEBUFFER_OPERATION'],
        ]);
        return m.get(e) || ('0x' + e.toString(16));
      }

      function compile(gl, type, src) {
        const sh = gl.createShader(type);
        gl.shaderSource(sh, src);
        gl.compileShader(sh);
        if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
          const info = gl.getShaderInfoLog(sh) || '';
          gl.deleteShader(sh);
          throw new Error(info);
        }
        return sh;
      }

      function makeProgram(gl, vs, fs) {
        const v = compile(gl, gl.VERTEX_SHADER, vs);
        const f = compile(gl, gl.FRAGMENT_SHADER, fs);
        const p = gl.createProgram();
        gl.attachShader(p, v);
        gl.attachShader(p, f);
        gl.linkProgram(p);
        gl.deleteShader(v);
        gl.deleteShader(f);
        if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
          const info = gl.getProgramInfoLog(p) || '';
          gl.deleteProgram(p);
          throw new Error(info);
        }
        return p;
      }

      function runProbe() {
        clearLog();
        const canvas = document.getElementById('c');
        const gl = canvas.getContext('webgl2', { antialias: false, depth: true, stencil: false });
        if (!gl) {
          log('ERROR: webgl2 not available');
          return;
        }

        log('WebGL:', gl.getParameter(gl.VERSION));
        log('GLSL :', gl.getParameter(gl.SHADING_LANGUAGE_VERSION));
        log('Vendor:', gl.getParameter(gl.VENDOR));
        log('Renderer:', gl.getParameter(gl.RENDERER));
        log('');

        const W = 128, H = 128;

        // 1) Depth-only FBO with depth texture
        const depthTex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, depthTex);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        try { gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_MODE, gl.NONE); } catch {}
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT16, W, H, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_SHORT, null);

        const fboDepth = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fboDepth);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTex, 0);
        gl.drawBuffers([gl.NONE]);
        gl.readBuffer(gl.NONE);
        const stDepth = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        log('Depth FBO status:', stDepth === gl.FRAMEBUFFER_COMPLETE ? 'COMPLETE' : stDepth);
        gl.viewport(0, 0, W, H);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);
        gl.depthMask(true);
        gl.colorMask(false, false, false, false);
        gl.clearDepth(1.0);
        gl.clear(gl.DEPTH_BUFFER_BIT);

        // Draw a triangle to populate depth.
        const vs = `#version 300 es
        precision highp float;
        const vec2 P[3] = vec2[3](vec2(-0.6, -0.6), vec2(0.8, -0.4), vec2(-0.2, 0.9));
        void main(){ gl_Position = vec4(P[gl_VertexID], 0.0, 1.0); }`;
        const fs = `#version 300 es
        precision highp float;
        out vec4 fragColor;
        void main(){ fragColor = vec4(1.0); }`;
        const prog = makeProgram(gl, vs, fs);
        gl.useProgram(prog);
        gl.drawArrays(gl.TRIANGLES, 0, 3);

        // 1a) Try depth readPixels
        const depthU16 = new Uint16Array(W * H);
        try { gl.getError(); } catch {}
        try {
          gl.readPixels(0, 0, W, H, gl.DEPTH_COMPONENT, gl.UNSIGNED_SHORT, depthU16);
        } catch (e) {
          log('Depth readPixels threw:', e);
        }
        const eDepth = gl.getError();
        log('Depth readPixels error:', glErrName(gl, eDepth));
        if (eDepth === gl.NO_ERROR) {
          let mn = 65535, mx = 0;
          for (let i = 0; i < depthU16.length; i++) { const v = depthU16[i]; if (v < mn) mn = v; if (v > mx) mx = v; }
          log('Depth U16 min/max:', mn, mx);
        }
        log('');

        // 2) RGBA fallback: draw depthTex into an RGBA8 FBO and readPixels RGBA
        const rgbaTex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, rgbaTex);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA8, W, H, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

        const fboRGBA = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fboRGBA);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, rgbaTex, 0);
        gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
        const stRGBA = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        log('RGBA FBO status:', stRGBA === gl.FRAMEBUFFER_COMPLETE ? 'COMPLETE' : stRGBA);
        gl.viewport(0, 0, W, H);
        gl.disable(gl.DEPTH_TEST);
        gl.colorMask(true, true, true, true);

        const vs2 = `#version 300 es
        precision highp float;
        const vec2 POS[3] = vec2[3](vec2(-1.0,-1.0), vec2(3.0,-1.0), vec2(-1.0,3.0));
        void main(){ gl_Position = vec4(POS[gl_VertexID], 0.0, 1.0); }`;
        const fs2 = `#version 300 es
        precision highp float;
        uniform sampler2D uDepthTex;
        out vec4 fragColor;
        vec3 packDepth24(float depth01) {
          float d = clamp(depth01, 0.0, 1.0);
          float u = floor(d * 16777215.0 + 0.5);
          float r = mod(u, 256.0);
          float g = mod(floor(u / 256.0), 256.0);
          float b = mod(floor(u / 65536.0), 256.0);
          return vec3(r,g,b)/255.0;
        }
        void main(){
          ivec2 ip = ivec2(gl_FragCoord.xy);
          float d = texelFetch(uDepthTex, ip, 0).r;
          vec3 rgb = packDepth24(d);
          fragColor = vec4(rgb, 1.0);
        }`;
        const prog2 = makeProgram(gl, vs2, fs2);
        gl.useProgram(prog2);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, depthTex);
        const loc = gl.getUniformLocation(prog2, 'uDepthTex');
        if (loc) gl.uniform1i(loc, 0);
        gl.drawArrays(gl.TRIANGLES, 0, 3);

        const rgba = new Uint8Array(W * H * 4);
        try { gl.getError(); } catch {}
        try {
          gl.readPixels(0, 0, W, H, gl.RGBA, gl.UNSIGNED_BYTE, rgba);
        } catch (e) {
          log('RGBA readPixels threw:', e);
        }
        const eRGBA = gl.getError();
        log('RGBA readPixels error:', glErrName(gl, eRGBA));
        if (eRGBA === gl.NO_ERROR) {
          // Decode a few pixels as sanity check.
          const idx = ((H >> 1) * W + (W >> 1)) * 4;
          const r = rgba[idx], g = rgba[idx+1], b = rgba[idx+2];
          const u24 = (r + (g << 8) + (b << 16)) >>> 0;
          const d01 = u24 / 16777215.0;
          log('Decoded center depth01 ~', d01.toFixed(6), '(packed RGB:', r, g, b, ')');
        }

        // Show the packed texture on the visible canvas.
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.viewport(0, 0, canvas.width, canvas.height);
        gl.disable(gl.DEPTH_TEST);
        // Draw the RGBA texture to screen quickly using the same shader (treating rgbaTex as depthTex is wrong),
        // so instead draw a simple textured quad shader for display.
        const vs3 = `#version 300 es
        precision highp float;
        const vec2 POS[3] = vec2[3](vec2(-1.0,-1.0), vec2(3.0,-1.0), vec2(-1.0,3.0));
        out vec2 vUV;
        void main(){
          vec2 p = POS[gl_VertexID];
          vUV = (p * 0.5) + 0.5;
          gl_Position = vec4(p, 0.0, 1.0);
        }`;
        const fs3 = `#version 300 es
        precision highp float;
        in vec2 vUV;
        uniform sampler2D uTex;
        out vec4 fragColor;
        void main(){ fragColor = texture(uTex, vUV); }`;
        const prog3 = makeProgram(gl, vs3, fs3);
        gl.useProgram(prog3);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, rgbaTex);
        const loc3 = gl.getUniformLocation(prog3, 'uTex');
        if (loc3) gl.uniform1i(loc3, 0);
        gl.drawArrays(gl.TRIANGLES, 0, 3);

        // Cleanup.
        gl.deleteProgram(prog);
        gl.deleteProgram(prog2);
        gl.deleteProgram(prog3);
        gl.deleteFramebuffer(fboDepth);
        gl.deleteFramebuffer(fboRGBA);
        gl.deleteTexture(depthTex);
        gl.deleteTexture(rgbaTex);

        log('');
        log('Done.');
      }

      document.getElementById('run').addEventListener('click', runProbe);
      document.getElementById('clear').addEventListener('click', clearLog);
    </script>
  </body>
</html>


