#!/usr/bin/env python3
"""
Generate a "ped control mapping" report from GTA5 client data using CodeWalker.

What it extracts (per ped init entry):
- ClipDictionaryName (anim dictionary)
- Movement clipsets: MovementClipSet(s), StrafeClipSet, MovementToStrafeClipSet, InjuredStrafeClipSet, SidestepClipSet
- Motion/task knobs: MotionTaskDataSetName, DefaultTaskDataSetName, TaskDataName, PoseMatcherName, PoseMatcherProneName, GetupSetHash
- Misc ped-control-adjacent: Pedtype, CreatureMetadataName, NavCapabilitiesName, PedCapsuleName, PedLayoutName, PedIKSettingsName

Notes:
- This is "strict GTA5 + CodeWalker": we are extracting the *data the engine uses* for locomotion/state machines.
- Raw input->movement mapping still lives in game code, but this report gives you the asset/state surface to map onto.
"""

from __future__ import annotations

import argparse
import json
import os
import sys
from dataclasses import dataclass, asdict
from pathlib import Path
from typing import Any, Iterable


CONTROL_FIELDS = [
    # identity / linkage
    "Name",
    "PropsName",
    "ClipDictionaryName",
    "Pedtype",
    # locomotion clipsets
    "MovementClipSet",
    "MovementClipSets",
    "StrafeClipSet",
    "MovementToStrafeClipSet",
    "InjuredStrafeClipSet",
    "SidestepClipSet",
    # state machine-ish knobs
    "PoseMatcherName",
    "PoseMatcherProneName",
    "GetupSetHash",
    "CreatureMetadataName",
    "DecisionMakerName",
    "MotionTaskDataSetName",
    "DefaultTaskDataSetName",
    "PedCapsuleName",
    "PedLayoutName",
    "PedIKSettingsName",
    "TaskDataName",
    # combat/aim/gesture (often impacts control feel)
    "DefaultGestureClipSet",
    "DefaultBrawlingStyle",
    "DefaultUnarmedWeapon",
    "CombatInfo",
    # misc (still useful)
    "RelationshipGroup",
    "NavCapabilitiesName",
    "PerceptionInfo",
]


def _safe_get(obj: Any, name: str) -> Any:
    try:
        return getattr(obj, name)
    except Exception:
        return None


def _net_string(x: Any) -> Any:
    # Convert pythonnet / .NET strings + arrays into JSON-safe Python primitives.
    if x is None:
        return None
    # .NET string behaves like Python str in pythonnet; still normalize.
    if isinstance(x, str):
        return x
    # Arrays / iterables: best-effort list conversion (avoid exploding on non-iterables).
    try:
        # pythonnet arrays have __len__ and are iterable
        return [_net_string(v) for v in x]
    except TypeError:
        return str(x)


def _looks_player_ped(name: str) -> bool:
    n = (name or "").lower()
    return n in {"player_zero", "player_one", "player_two"} or n.startswith("player_")


def find_peds_definition_paths(rpf_manager) -> list[str]:
    """
    Find likely peds definition files in RPFS.
    Common names include `peds.ymt` and `peds.meta`.
    """
    hits: list[str] = []
    for rpf in rpf_manager.AllRpfs:
        entries = getattr(rpf, "AllEntries", None)
        if not entries:
            continue
        for e in entries:
            name = str(e.Name).lower()
            if name in {"peds.ymt", "peds.meta"}:
                hits.append(str(e.Path))
    # de-dupe while keeping order
    seen = set()
    out = []
    for p in hits:
        if p in seen:
            continue
        seen.add(p)
        out.append(p)
    return out


def load_peds_file(rpf_manager, PedsFileType, path: str):
    entry = rpf_manager.GetEntry(path)
    if not entry:
        raise RuntimeError(f"Entry not found: {path}")
    data = rpf_manager.GetFileData(path)
    if not data:
        raise RuntimeError(f"No data for: {path}")

    pf = PedsFileType()
    pf.Load(data, entry)
    return pf


def extract_initdata_rows(peds_file, source_path: str) -> list[dict[str, Any]]:
    rows: list[dict[str, Any]] = []
    init_list = _safe_get(peds_file, "InitDataList")
    if not init_list:
        return rows
    init_datas = _safe_get(init_list, "InitDatas")
    if not init_datas:
        return rows

    for item in init_datas:
        row: dict[str, Any] = {"source_peds_file": source_path}
        for f in CONTROL_FIELDS:
            val = _safe_get(item, f)
            row[f] = _net_string(val)
        row["_is_player_ped"] = _looks_player_ped(row.get("Name") or "")
        rows.append(row)
    return rows


def render_markdown(rows: list[dict[str, Any]], sources: list[str]) -> str:
    lines: list[str] = []
    lines.append("# Generated: Ped control mapping (GTA5 client data via CodeWalker)")
    lines.append("")
    lines.append("Generated by `scripts/generate_ped_control_mapping.py`.")
    lines.append("")
    lines.append("## What this is")
    lines.append("")
    lines.append("This is an extracted table of ped movement/control-adjacent data used by the engine:")
    lines.append("- locomotion clipsets (movement/strafe/transition/injured/sidestep)")
    lines.append("- animation dictionary name (`ClipDictionaryName`)")
    lines.append("- motion/task dataset names and pose matchers (which gate state machines)")
    lines.append("")
    lines.append("You can map user inputs by tying your input-state machine (walk/run/sprint/crouch/strafe/aim/cover) to these clipsets and task datasets.")
    lines.append("")

    lines.append("## Sources scanned")
    lines.append("")
    for s in sources:
        lines.append(f"- `{s}`")
    lines.append("")

    lines.append("## Counts")
    lines.append("")
    lines.append(f"- **Total peds**: `{len(rows)}`")
    player_rows = [r for r in rows if r.get("_is_player_ped")]
    lines.append(f"- **Player peds**: `{len(player_rows)}`")
    lines.append("")

    def mini_table(title: str, subset: Iterable[dict[str, Any]], max_rows: int = 50) -> None:
        lines.append(f"## {title}")
        lines.append("")
        lines.append("| ped | MovementClipSet | StrafeClipSet | ClipDictionaryName | MotionTaskDataSetName | DefaultTaskDataSetName |")
        lines.append("|---|---|---|---|---|---|")
        i = 0
        for r in subset:
            if i >= max_rows:
                break
            lines.append(
                "| "
                + " | ".join(
                    [
                        str(r.get("Name") or ""),
                        str(r.get("MovementClipSet") or ""),
                        str(r.get("StrafeClipSet") or ""),
                        str(r.get("ClipDictionaryName") or ""),
                        str(r.get("MotionTaskDataSetName") or ""),
                        str(r.get("DefaultTaskDataSetName") or ""),
                    ]
                )
                + " |"
            )
            i += 1
        lines.append("")
        if len(list(subset)) > max_rows:
            lines.append(f"_Truncated to first {max_rows} rows._")
            lines.append("")

    # Only show player peds first (high-signal), then a small sample of the full set.
    if player_rows:
        mini_table("Player peds (first pass)", player_rows, max_rows=25)
    mini_table("Sample (first 50)", rows, max_rows=50)

    lines.append("## Full data")
    lines.append("")
    lines.append("See the JSON export for full fields per ped:")
    lines.append("- `docs/generated/ped-control-mapping.json`")
    lines.append("")
    return "\n".join(lines)


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument(
        "--gta5-path",
        default=os.environ.get("gta5_path") or os.environ.get("GTA5_PATH") or "",
        help="Path to GTA5 install folder (contains GTA5.exe, common.rpf, update/...).",
    )
    ap.add_argument("--out-md", default="docs/generated/ped-control-mapping.md")
    ap.add_argument("--out-json", default="docs/generated/ped-control-mapping.json")
    args = ap.parse_args()

    repo_root = Path(os.getcwd()).resolve()
    if str(repo_root) not in sys.path:
        sys.path.insert(0, str(repo_root))

    gta5_path = Path(args.gta5_path).expanduser().resolve() if args.gta5_path else Path()
    if not gta5_path.exists():
        raise SystemExit(
            "--gta5-path is required (or set env gta5_path). "
            "Example: --gta5-path /data/webglgta/webgl-gta/gtav"
        )

    out_md = Path(args.out_md)
    out_json = Path(args.out_json)
    if not out_md.is_absolute():
        out_md = (repo_root / out_md).resolve()
    if not out_json.is_absolute():
        out_json = (repo_root / out_json).resolve()

    from gta5_modules.dll_manager import DllManager

    dm = DllManager(str(gta5_path))
    if not dm.initialized:
        raise SystemExit("DllManager failed to initialize (see logs).")

    rm = dm.get_rpf_manager()

    # import the C# type
    from CodeWalker.GameFiles import PedsFile as PedsFileType

    sources = find_peds_definition_paths(rm)
    if not sources:
        raise SystemExit("No peds.ymt or peds.meta found in RPFS.")

    all_rows: list[dict[str, Any]] = []
    for p in sources:
        try:
            pf = load_peds_file(rm, PedsFileType, p)
            all_rows.extend(extract_initdata_rows(pf, p))
        except Exception as e:
            # Keep going; some sources may fail to parse depending on format.
            all_rows.append({"source_peds_file": p, "_error": str(e)})

    out_md.parent.mkdir(parents=True, exist_ok=True)
    out_json.parent.mkdir(parents=True, exist_ok=True)

    out_json.write_text(json.dumps(all_rows, indent=2, ensure_ascii=False), encoding="utf-8")
    out_md.write_text(render_markdown(all_rows, sources), encoding="utf-8")

    print(f"Wrote: {out_md}")
    print(f"Wrote: {out_json}")
    print(f"Rows: {len(all_rows)} (including any _error rows)")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())


